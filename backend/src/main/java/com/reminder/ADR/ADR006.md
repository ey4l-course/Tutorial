# ADR: Transaction Classification Mechanism

**Status:** Accepted  
**Date:** 2025-08-11

## Context

When creating a new transaction, the system must determine the correct `category` value before persistence.  
This classification influences analytics, reports, and future categorization logic.  
A transaction can arrive with or without a user-defined category.

## Decision

The classification mechanism always runs **before** calling `repo.save()` and uses three possible category sources:

1. **User manually set a category**
    - Preserves the transaction’s existing `category`.
    - Sets:
        - `categorySource = SPECIAL_CLASSIFICATION`
        - `uniqueWeight = 1`

2. **User did not set a category, but a permanent mapping exists**
    - Looks up a `userDefinedCategory` from past `(userId, description)` pairs.
    - If found:
        - `category = userDefinedCategory`
        - `categorySource = PERMANENT_CLASSIFICATION`
        - `uniqueWeight = 0`

3. **User did not set a category and no mapping exists**
    - Defaults to:
        - `category = 0` (unclassified)
        - `categorySource = GLOBAL_DEFAULT`
        - `uniqueWeight = 1`

**Additional normalization rule:**  
All transaction amounts are scaled to two decimal places using `RoundingMode.HALF_DOWN`.

### CategorySource Enum Values
- `GLOBAL_DEFAULT` – Used when no prior mapping exists and user didn’t set a category.
- `PERMANENT_CLASSIFICATION` – Based on a previously stored user-specific category.
- `SPECIAL_CLASSIFICATION` – User manually assigned category in the current transaction.

## Rationale

- **`uniqueWeight` meaning**:  
  Acts as an influence factor for downstream classification updates.  
  Periodic background jobs count `(description, category)` pairs to adjust global classification rules.  
  Transactions with `uniqueWeight = 1` contribute to category-learning heuristics,  
  while `uniqueWeight = 0` excludes confirmed permanent classifications from biasing the global model.

- **Always run before save**:  
  Guarantees consistent category assignment and avoids storing unclassified or inconsistent data.

## Consequences

- Improves user experience by reusing prior classification history.
- Reduces friction for recurring transaction descriptions.
- Ensures all persisted transactions have a valid `categorySource`.
- Maintains a clean fallback path for truly new or ambiguous transactions.
- Adds dependency on the `repo.userDefinedCategory()` lookup.

## Alternatives Considered

- **Require manual category selection for every transaction**
    - Pros: Full control, no ambiguity.
    - Cons: Poor usability, high friction for frequent payees.
- **Machine-learning auto-classification**
    - Pros: Potentially more accurate over time.
    - Cons: Higher complexity, data requirements, and maintenance.
